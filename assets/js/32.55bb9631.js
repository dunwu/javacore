(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{372:function(e,t,a){"use strict";a.r(t);var r=a(4),v=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"java-容器之-stream"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-容器之-stream"}},[e._v("#")]),e._v(" Java 容器之 Stream")]),e._v(" "),t("h2",{attrs:{id:"stream-简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#stream-简介"}},[e._v("#")]),e._v(" Stream 简介")]),e._v(" "),t("p",[e._v("在 Java8 中，"),t("code",[e._v("Collection")]),e._v(" 新增了两个流方法，分别是 "),t("code",[e._v("stream()")]),e._v(" 和 "),t("code",[e._v("parallelStream()")]),e._v("。")]),e._v(" "),t("p",[t("code",[e._v("Stream")]),e._v(" 相当于高级版的 "),t("code",[e._v("Iterator")]),e._v("，他可以通过 Lambda 表达式对集合进行各种非常便利、高效的聚合操作（Aggregate Operation），或者大批量数据操作 (Bulk Data Operation)。")]),e._v(" "),t("h2",{attrs:{id:"stream-操作分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#stream-操作分类"}},[e._v("#")]),e._v(" Stream 操作分类")]),e._v(" "),t("p",[e._v("官方将 Stream 中的操作分为两大类：中间操作（Intermediate operations）和终结操作（Terminal operations）。")]),e._v(" "),t("p",[e._v("中间操作又可以分为无状态（Stateless）与有状态（Stateful）操作，前者是指元素的处理不受之前元素的影响，后者是指该操作只有拿到所有元素之后才能继续下去。")]),e._v(" "),t("p",[e._v("终结操作又可以分为短路（Short-circuiting）与非短路（Unshort-circuiting）操作，前者是指遇到某些符合条件的元素就可以得到最终结果，后者是指必须处理完所有元素才能得到最终结果。")]),e._v(" "),t("h2",{attrs:{id:"stream-源码实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#stream-源码实现"}},[e._v("#")]),e._v(" Stream 源码实现")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/dunwu/images/master/snap/20201205174140.jpg",alt:"img"}})]),e._v(" "),t("p",[t("code",[e._v("BaseStream")]),e._v(" 和 "),t("code",[e._v("Stream")]),e._v(" 是最顶层的接口类。"),t("code",[e._v("BaseStream")]),e._v(" 主要定义了流的基本接口方法，例如，spliterator、isParallel 等；"),t("code",[e._v("Stream")]),e._v(" 则定义了一些流的常用操作方法，例如，map、filter 等。")]),e._v(" "),t("p",[t("code",[e._v("Sink")]),e._v(" 接口是定义每个 "),t("code",[e._v("Stream")]),e._v(" 操作之间关系的协议，他包含 "),t("code",[e._v("begin()")]),e._v("、"),t("code",[e._v("end()")]),e._v("、"),t("code",[e._v("cancellationRequested()")]),e._v("、"),t("code",[e._v("accpt()")]),e._v(" 四个方法。"),t("code",[e._v("ReferencePipeline")]),e._v(" 最终会将整个 "),t("code",[e._v("Stream")]),e._v(" 流操作组装成一个调用链，而这条调用链上的各个 "),t("code",[e._v("Stream")]),e._v(" 操作的上下关系就是通过 "),t("code",[e._v("Sink")]),e._v(" 接口协议来定义实现的。")]),e._v(" "),t("p",[t("code",[e._v("ReferencePipeline")]),e._v(" 是一个结构类，他通过定义内部类组装了各种操作流。他定义了 "),t("code",[e._v("Head")]),e._v("、"),t("code",[e._v("StatelessOp")]),e._v("、"),t("code",[e._v("StatefulOp")]),e._v(" 三个内部类，实现了 "),t("code",[e._v("BaseStream")]),e._v(" 与 "),t("code",[e._v("Stream")]),e._v(" 的接口方法。Head 类主要用来定义数据源操作，在初次调用 names.stream() 方法时，会加载 Head 对象，此时为加载数据源操作；接着加载的是中间操作，分别为无状态中间操作 StatelessOp 对象和有状态操作 StatefulOp 对象，此时的 Stage 并没有执行，而是通过 AbstractPipeline 生成了一个中间操作 Stage 链表；当我们调用终结操作时，会生成一个最终的 Stage，通过这个 Stage 触发之前的中间操作，从最后一个 Stage 开始，递归产生一个 Sink 链。")]),e._v(" "),t("h2",{attrs:{id:"stream-并行处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#stream-并行处理"}},[e._v("#")]),e._v(" Stream 并行处理")]),e._v(" "),t("p",[e._v("Stream 处理数据的方式有两种，串行处理和并行处理。")]),e._v(" "),t("h2",{attrs:{id:"_4-参考资料"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-参考资料"}},[e._v("#")]),e._v(" 4. 参考资料")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://item.jd.com/10058164.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java 编程思想（第 4 版）"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=v.exports}}]);