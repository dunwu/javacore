# Java 编程规范

> 编程规范就是 Java 开发的最佳实践。帮助开发人员少走弯路。

## Effective Java

- 第 2 章 创建、销毁对象
  - 第 1 条：考虑用静态工厂方法代替构造器
  - 第 2 条：遇到多个构造器参数时要考虑用构建器
  - 第 3 条：用私有构造器或者枚举类型强化 Singleton 属性
  - 第 4 条：通过私有构造器强化不可实例化的能力
  - 第 5 条：避免创建不必要的对象
  - 第 6 条：消除过期的对象引用
  - 第 7 条：避免使用终结方法
- 第 3 章 对于所有对象都通用的方法
  - 第 8 条：覆盖 equals 时请遵守通用约定
  - 第 9 条：覆盖 equals 时总要覆盖 hashCode
  - 第 10 条：始终要覆盖 toString
  - 第 11 条：谨慎地覆盖 clone
  - 第 12 条：考虑实现 Comparable 接口
- 第 4 章 类和接口
  - 第 13 条：使类和成员的可访问性最小化
  - 第 14 条：在公有类中使用访问方法而非公有域
  - 第 15 条：使可变性最小化
  - 第 16 条：复合优先于继承
  - 第 17 条：要么为继承而设计，并提供文档说明，要么就禁止继承
  - 第 18 条：接口优于抽象类
  - 第 19 条：接口只用于定义类型
  - 第 20 条：类层次优于标签类
  - 第 21 条：用函数对象表示策略
  - 第 22 条：优先考虑静态成员类
- 第 5 章 泛型
  - 第 23 条：请不要在新代码中使用原生态类型
  - 第 24 条：消除非受检警告
  - 第 25 条：列表优先于数组
  - 第 26 条：优先考虑泛型
  - 第 27 条：优先考虑泛型方法
  - 第 28 条：利用有限制通配符来提升 API 的灵活性
  - 第 29 条：优先考虑类型安全的异构容器
- 第 6 章 枚举和注解
  - 第 30 条：用 enum 代替 int 常量
  - 第 31 条：用实例域代替序数
  - 第 32 条：用 EnumSet 代替位域
  - 第 33 条：用 EnumMap 代替序数索引
  - 第 34 条：用接口模拟可伸缩的枚举
  - 第 35 条：注解优先于命名模式
  - 第 36 条：坚持使用 Override 注解
  - 第 37 条：用标记接口定义类型
- 第 7 章 方法
  - 第 38 条：检查参数的有效性
  - 第 39 条：必要时进行保护性拷贝
  - 第 40 条：谨慎设计方法签名
  - 第 41 条：慎用重载
  - 第 42 条：慎用可变参数
  - 第 43 条：返回零长度的数组或者集合，而不是：null
  - 第 44 条：为所有导出的 API 元素编写文档注释
- 第 8 章 通用程序设计
  - 第 45 条：将局部变量的作用域最小化
  - 第 46 条：for-each 循环优先于传统的 for 循环
  - 第 47 条：了解和使用类库
  - 第 48 条：如果需要精确的答案，请避免使用 float 和 double
  - 第 49 条：基本类型优先于装箱基本类型
  - 第 50 条：如果其他类型更适合，则尽量避免使用字符串
  - 第 51 条：当心字符串连接的性能
  - 第 52 条：通过接口引用对象
  - 第 53 条：接口优先于反射机制
  - 第 54 条：谨慎地使用本地方法
  - 第 55 条：谨慎地进行优化
  - 第 56 条：遵守普遍接受的命名惯例
- 第 9 章 异常
  - 第 57 条：只针对异常的情况才使用异常
  - 第 58 条：对可恢复的情况使用受检异常，对编程错误使用运行时异常
  - 第 59 条：避免不必要地使用受检的异常
  - 第 60 条：优先使用标准的异常
  - 第 61 条：抛出与抽象相对应的异常
  - 第 62 条：每个方法抛出的异常都要有文档
  - 第 63 条：在细节消息中包含能捕获失败的信息
  - 第 64 条：努力使失败保持原子性
  - 第 65 条：不要忽略异常
- 第 10 章 并发
  - 第 66 条：同步访问共享的可变数据
  - 第 67 条：避免过度同步
  - 第 68 条：executor 和 task 优先干线程
  - 第 69 条：并发工具优先于 wait 和 notify
  - 第 70 条：线程安全性的文档化
  - 第 71 条：慎用延迟初始化
  - 第 72 条：不要依赖于线程调度器
  - 第 73 条：避免使用线程组
- 第 11 章 序列化
  - 第 74 条：谨慎地实现 Serializable 接口
  - 第 75 条：考虑使用自定义的序列化形式
  - 第 76 条：保护性地编写 readObject 方法
  - 第 77 条：对于实例控制，枚举类型优先于 readResolve
  - 第 78 条：考虑用序列化代理代替序列化实例

## 资源

- [Effective Java](https://book.douban.com/subject/3360807/)
- [阿里巴巴 Java 开发手册](https://github.com/alibaba/p3c/blob/master/阿里巴巴Java开发手册（详尽版）.pdf)
- [Google Java 编程指南](https://google.github.io/styleguide/javaguide.html)
