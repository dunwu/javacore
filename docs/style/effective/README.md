# Effective Java 规则一览

## [第2章 创建、销毁对象](effective/chapter02.html)

第1条：考虑用静态工厂方法代替构造器

第2条：遇到多个构造器参数时要考虑用构建器

第3条：用私有构造器或者枚举类型强化Singleton属性

第4条：通过私有构造器强化不可实例化的能力

第5条：避免创建不必要的对象

第6条：消除过期的对象引用

第7条：避免使用终结方法

## [第3章 对于所有对象都通用的方法](effective/chapter03.html)

第8条：覆盖equals时请遵守通用约定

第9条：覆盖equals时总要覆盖hashCode

第10条：始终要覆盖toString

第11条：谨慎地覆盖clone

第12条：考虑实现Comparable接口

## [第4章 类和接口](effective/chapter04.html)

第13条：使类和成员的可访问性最小化

第14条：在公有类中使用访问方法而非公有域

第15条：使可变性最小化

第16条：复合优先于继承

第17条：要么为继承而设计，并提供文档说明，要么就禁止继承

第18条：接口优于抽象类

第19条：接口只用于定义类型

第20条：类层次优于标签类

第21条：用函数对象表示策略

第22条：优先考虑静态成员类

## 第5章 泛型

第23条：请不要在新代码中使用原生态类型

第24条：消除非受检警告

第25条：列表优先于数组

第26条：优先考虑泛型

第27条：优先考虑泛型方法

第28条：利用有限制通配符来提升API的灵活性

第29条：优先考虑类型安全的异构容器

## 第6章 枚举和注解

第30条：用enum代替int常量

第31条：用实例域代替序数

第32条：用EnumSet代替位域

第33条：用EnumMap代替序数索引

第34条：用接口模拟可伸缩的枚举

第35条：注解优先于命名模式

第36条：坚持使用Override注解

第37条：用标记接口定义类型

## 第7章 方法

第38条：检查参数的有效性

第39条：必要时进行保护性拷贝

第40条：谨慎设计方法签名

第41条：慎用重载

第42条：慎用可变参数

第43条：返回零长度的数组或者集合，而不是：null

第44条：为所有导出的API元素编写文档注释

## 第8章 通用程序设计

第45条：将局部变量的作用域最小化

第46条：for-each循环优先于传统的for循环

第47条：了解和使用类库

第48条：如果需要精确的答案，请避免使用float和double

第49条：基本类型优先于装箱基本类型

第50条：如果其他类型更适合，则尽量避免使用字符串

第51条：当心字符串连接的性能

第52条：通过接口引用对象

第53条：接口优先于反射机制

第54条：谨慎地使用本地方法

第55条：谨慎地进行优化

第56条：遵守普遍接受的命名惯例

## 第9章 异常

第57条：只针对异常的情况才使用异常

第58条：对可恢复的情况使用受检异常，对编程错误使用运行时异常

第59条：避免不必要地使用受检的异常

第60条：优先使用标准的异常

第61条：抛出与抽象相对应的异常

第62条：每个方法抛出的异常都要有文档

第63条：在细节消息中包含能捕获失败的信息

第64条：努力使失败保持原子性

第65条：不要忽略异常

## 第10章 并发

第66条：同步访问共享的可变数据

第67条：避免过度同步

第68条：executor和task优先干线程

第69条：并发工具优先于wait和notify

第70条：线程安全性的文档化

第71条：慎用延迟初始化

第72条：不要依赖于线程调度器

第73条：避免使用线程组

## 第11章 序列化

第74条：谨慎地实现Serializable接口

第75条：考虑使用自定义的序列化形式

第76条：保护性地编写readObject方法

第77条：对于实例控制，枚举类型优先于readResolve

第78条：考虑用序列化代理代替序列化实例
